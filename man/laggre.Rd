% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/aggregating.R
\name{laggre}
\alias{laggre}
\title{Aggregation of split \code{Lexis} data}
\usage{
laggre(lex, aggre = NULL, breaks = NULL, type = c("unique", "full"),
  expr = NULL, subset = NULL, substituted = FALSE, verbose = FALSE)
}
\arguments{
\item{lex}{a \code{Lexis} object split with e.g. 
\code{\link[Epi]{splitLexis}} or \code{\link{splitMulti}}}

\item{aggre}{expression(s) or variables to aggregate by; can be 
1) a character string vector of variable names (e.g. \code{aggre = c("sex", "area")});
2) an expression or symbol (e.g. \code{aggre = sex} or 
\code{aggre = factor(sex, 0:1, c("m", "f"))});
3) a list of expressions or symbols (e.g. \code{aggre = list(gender = sex, area)});
automatic aggregation over Lexis time scales mentioned here; 
see Details and Examples}

\item{breaks}{if \code{NULL}, uses the breaks that were used to split the data
to categorize time scales mentioned in \code{aggre} using \code{cut}; otherwise
uses the supplied named list of breaks; see Details}

\item{type}{determines outputted levels to which data is aggregated varying
from returning only rows with \code{pyrs > 0} (\code{"unique"}) to
returning all possible combinations of variables given in \code{aggre} even
if those combinations are not represented in data (\code{"full"}); see Details}

\item{expr}{a (preferably named) list of expressions which will be computed in addition
to person-time and events; e.g. \code{list(d.exp = lex.dur*pop.haz)};
see Examples}

\item{subset}{a logical condition to subset by before computations;
e.g. \code{subset = area \%in\% c("A", "B")}}

\item{substituted}{\code{logical}, advanced; if \code{TRUE}, the supplied
\code{aggre} is a \code{call} object as a result of using \code{substitute}
or \code{quote}; useful for when using this function within another function}

\item{verbose}{\code{logical}; if \code{TRUE}, the function returns timings
and some information useful for debugging along the aggregation process}
}
\value{
A long \code{data.frame} or \code{data.table} of aggregated person-years 
(\code{pyrs}), numbers of subjects at risk (\code{at.risk}), and events
formatted \code{fromXtoY}, where \code{X} and \code{X} are states transitioning
from and to or states at the end of each \code{lex.id}'s follow-up 
(implying \code{X} = \code{Y}). Subjects at risk are computed in the beginning
of an interval defined by any Lexis time scales and mentioned in \code{aggre},
but events occur at any point within an interval.
}
\description{
Aggregates a split \code{Lexis} object by given variables 
and / or expressions into a long-format table of person-years and 
transitions / end-points. Automatic aggregation over time scales
by which data has been split if the respective time scales are mentioned
in the aggregation argument to e.g. intervals of calendar time, follow-up time
and/or age.
}
\details{
\strong{Basics}

\code{laggre} is intented for aggregation of split \code{Lexis} data only.
See \code{\link[Epi]{Lexis}} for forming \code{Lexis} objects by hand
and e.g. \code{\link[Epi]{splitLexis}}, \code{\link{splitLexisDT}}, and
\code{\link{splitMulti}} for splitting the data. \code{\link{lexpand}}
may be used for simple data sets to do both steps as well as aggregation
in the same function call.

Here aggregation refers to computing person-years and the appropriate events
(state transitions and end points in status) for the subjects in the data.
Hence, it computes e.g. deaths (end-point and state transition) and 
censorings (end-point) as well as events in a multi-state setting
(state transitions).

The result is a long-format \code{data.frame} or \code{data.table}
(depending on \code{options("popEpi.datatable")}; see \code{?popEpi})
with the columns \code{pyrs} and the appropriate transitions named as
\code{fromXtoY}, e.g. \code{from0to0} and \code{from0to1} depending
on the values of \code{lex.Cst} and \code{lex.Xst}.


\strong{The aggre argument}

The \code{aggre} argument determines the length of the table, i.e.
the combinations of variables to which data is aggregated.  
\code{aggre} is relatively flexible, as it can be supplied as

\itemize{
 \item{a character string vector, e.g. \code{c("sex", "area")}, naming variables existing in \code{lex}}
 \item{an expression, e.g. \code{factor(sex, 0:1, c("m", "f"))} using any variable found in \code{lex}}
 \item{a list (fully or partially named) of expressions, e.g. \code{list(gender = factor(sex, 0:1, c("m", "f"), area)}}
}

Note that expressions effectively allow a variable to be supplied simply as
e.g. \code{aggre = sex} (as a symbol/name in R lingo).

The data is then aggregated to the levels of the given variables 
or expression(s). Variables defined to be time scales in the supplied 
\code{Lexis} are processed in a special way: If any are mentioned in the
\code{aggre} argument, intervals of them are formed based on the breaks
used to split the data: e.g. if \code{age} was split using the breaks 
\code{c(0, 50, Inf)}, mentioning \code{age} in \code{aggre} leads to
creating the \code{age} intervals \code{[0, 50)} and \code{[50, Inf)}
and aggregating to them. The intervals are identified in the output
as the lower bounds of the appropriate intervals.

It is possible but not recommended to also supply the argument \code{breaks}, 
a list of breaks as in \code{splitMulti}, but this may go wrong;
It is mainly included for when the meta information about the 
breaks used to split the data is lost due to modifying \code{lex}
in certain ways after splitting.

\strong{Aggregation types (styles)}

It is almost always enough to aggregate the data to variable levels
that are actually represented in the data 
(default \code{aggre = "unique"}; alias \code{"non-empty"}). 
For certain uses it may be useful
to have also "empty" levels represented (resulting in some rows in output
with zero person-years and events); in these cases supplying
\code{aggre = "full"} (alias \code{"cartesian"}) causes \code{aggre}
to determine the Cartesian product of all the levels of the supplied \code{aggre}
variables or expressions and aggregate to them. As an example
of a Cartesian product, try

\code{merge(1:2, 1:5)}.
}
\examples{

## form a Lexis object
library(Epi)
data(sibr)
x <- sibr[1:10,]
x[1:5,]$sex <- 0 ## pretend some are male
x <- Lexis(data = x,
           entry = list(AGE = dg_age, CAL = get.yrs(dg_date)),
           exit = list(CAL = get.yrs(ex_date)),
           entry.status=0, exit.status = status)
x <- splitMulti(x, breaks = list(CAL = seq(1993, 2013, 5), 
                                 AGE = seq(0, 100, 50)))

## these produce the same results (with differing ways of determining aggre)
a1 <- laggre(x, aggre = list(gender = factor(sex, 0:1, c("m", "f")), 
             agegroup = AGE, period = CAL))

a2 <- laggre(x, aggre = c("sex", "AGE", "CAL"))

a3 <- laggre(x, aggre = list(sex, agegroup = AGE, CAL))

## returning also empty levels
a4 <- laggre(x, aggre = c("sex", "AGE", "CAL"), type = "full")

## computing also expected numbers of cases
x <- lexpand(sibr[1:10,], birth = bi_date, entry = dg_date,
             exit = ex_date, status = status \%in\% 1:2, 
             pophaz = popmort, fot = 0:5, age = c(0, 50, 100))
a5 <- laggre(x, aggre = c("sex", "age", "fot"), 
             expr = list(d.exp = sum(lex.dur*pop.haz)))
             
## computing pohar-perme weighted figures
a6 <- laggre(x, aggre = c("sex", "age", "fot"), 
             expr = list(d.exp.pp = sum(lex.dur*pop.haz*pp)))

}
\author{
Joonas Miettinen
}

