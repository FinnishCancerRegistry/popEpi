% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/wip_survival_revamp.R
\name{survival_revamp}
\alias{survival_revamp}
\alias{surv_merge}
\alias{surv_split_merge_aggregate_by_stratum}
\title{Survival Time Statistics}
\usage{
surv_merge(dt, merge_dt, merge_dt_by, merge_dt_harmonisers = NULL)

surv_split_merge_aggregate_by_stratum(
  dt,
  breaks = list(ts_cal = 2000:2025, ts_age = 0:100, ts_fot = seq(0, 5, 1/12)),
  merge_dt = data.table::data.table(sex = 0L, ts_cal = 2000L, ts_age = 0L, haz = 0.01),
  merge_dt_by = c("sex", "ts_cal", "ts_age"),
  merge_dt_harmonisers = NULL,
  aggre_stratum_dt = data.table::CJ(sex = 0:1, study_arm = 0:1),
  aggre_ts_col_nms = "ts_fot",
  aggre_values = quote(list(total_subject_time = sum(lex.dur), n_events = sum(lex.Xst !=
    lex.Cst))),
  optional_steps = NULL
)
}
\description{
Functions used for estimation of various survival time statistics.
E.g. relative survival.
}
\section{Functions}{

\strong{popEpi::surv_merge}

\code{popEpi::surv_merge} can be used to merge additional information into
\code{Lexis} data, allowing the use of the \code{Lexis} time scales in the
merge. The typical use-case is to split \code{Lexis} data and then merge
population (expected) hazards to the subject-intervals.
\code{popEpi::surv_merge} performs the following steps:
\itemize{
\item If \code{is.null(merge_dt_harmonisers)}, \code{popEpi::surv_merge} attempts to
automatically determine the harmonisers making use of \code{cut} by looking
at the unique
values of the time scale to merge by in \code{merge_dt} (e.g. calendar year
in \code{ts_cal}):
\itemize{
\item If \code{merge_dt[[col_nm]]} contains numbers in increments of one and
nothing else, we define the \code{cut} breaks as the unique values of
\code{merge_dt[[col_nm]]} and as the ceiling
\code{max(merge_dt[[col_nm]]) + 1L}. E.g.
\code{1950:2021} for \code{merge_dt[[col_nm]]} containing unique values
\code{1950:2020}.
\item If \code{merge_dt[[col_nm]]} contains numbers but they are not all in
increments of one then
we define \code{cut} breaks as the unique values of
\code{merge_dt[[col_nm]]} and as the ceiling
\code{max(merge_dt[[col_nm]]) + last_diff}. Where \code{last_diff} is the
difference between the highest and second highest values. E.g.
\code{c(1950, 1960, 1970:2020, 2021)} for \code{merge_dt[[col_nm]]}
containing unique values \code{c(1950, 1960, 1970:2020)}.
\item If \code{merge_dt[[col_nm]]} does not contain numbers, an error is
raised because we don't know how to automatically form a
harmoniser.
\item With the \code{cut} breaks defined, the automatically created harmoniser
becomes a \code{cut} call with arguments
\itemize{
\item \code{x = COL + lex.dur / 2}, where \code{COL} is the current column,
\item \code{breaks} as specified above,
\item \code{right = FALSE}, and
\item \code{labels = FALSE}.
}
\item This results in indices to the breaks, and the harmoniser returns
break values at those indices. E.g. the cut results in
\code{3} in \code{breaks = c(1950, 1960, 1970:2020, 2021)} and output is
\code{1970} for every value of \code{COL + lex.dur / 2} in the interval
\verb{]1970, 1971]}.
}
\item Armed with either user-defined or automatically created
\code{merge_dt_harmonisers}, they are each evaluated to create a temporary
\code{data.table} with harmonised data from \code{dt}. This is performed via
\code{eval} with \code{envir = dt} and \code{enclos = call_env} where \code{call_env} is the
environment where \code{popEpi::surv_merge} was called. Of course if a column
has no harmoniser at this point then it is used as-is. For instance there
is no need to harmonise stratifying columns because they are not changed
by splitting the \code{Lexis} data.
\item Then we perform the actual merge between \code{merge_dt} and the harmonised
data. This merges in data from \code{merge_dt} into every row of \code{dt} in-place.
So \code{dt} is modified and no additional copy is taken for the sake of
efficiency.
\item Each merged-in column from \code{merge_dt} (all columns not in \code{merge_dt_by})
are inspected for missing values. If there are any, an error is raised.
This usually occurs if \code{merge_dt} does not contain data for all data in
\code{dt}. For instance it only covers years 1950-2020 but \code{dt} contains also
data for 2021. This error helps you to spot those problems early instead
of producing nonsense results downstream.
\item \code{popEpi::surv_merge} returns \code{dt} invisibly after adding columns from
\code{merge_dt} into \code{dt} in-place, without taking a copy.
}


\strong{popEpi::surv_split_merge_aggregate_by_stratum}

\code{popEpi::surv_split_merge_aggregate_by_stratum} can be used to split \code{Lexis}
(\verb{[Epi::Lexis]}) data, merge something to it after the merge, and
then perform an aggregation step. The following steps are performed:
\itemize{
\item Call
\code{optional_steps[["on_entry"]](eval_env = eval_env, call_env = call_env)}
if that \code{optional_steps} element exists.
\code{eval_env} is the temporary evaluation environment of
\code{popEpi::surv_split_merge_aggregate_by_stratum} which contains all
contains all the arguments of
\code{popEpi::surv_split_merge_aggregate_by_stratum} and \code{call_env} is the environment
where it was called.
\item Call
\code{on.exit(optional_steps[["on_exit"]](eval_env = eval_env, call_env = call_env))}
if that \code{optional_steps} element exists.
\item For each stratum in \code{aggre_stratum_dt}:
\itemize{
\item Run
\code{optional_steps[["stratum_on_entry"]](stratum_eval_env = stratum_eval_env, eval_env = eval_env, call_env = call_env)}
if that \code{optional_steps} element exists.
\code{stratum_eval_env} is the environment where the stratum-specific
steps are performed.
\item Run
\code{surv_split} on the subset of \code{dt} which contains data from the
current stratum.
\item Run
\code{optional_steps[["stratum_post_split"]](stratum_eval_env = stratum_eval_env, eval_env = eval_env, call_env = call_env)}
if that \code{optional_steps} element exists.
\item Run
\code{surv_merge} with \code{merge_dt} + \code{merge_dt_by}.
\item Run
\code{optional_steps[["stratum_post_merge"]](stratum_eval_env = stratum_eval_env, eval_env = eval_env, call_env = call_env)}
if that \code{optional_steps} element exists.
\item Evaluate \code{aggre_values_expr} in the context of the split data
with merged-in additional data. The enclosing environment is
\code{call_env}. See \code{?eval}.
\item Run
\code{optional_steps[["stratum_post_aggregation"]](stratum_eval_env = stratum_eval_env, eval_env = eval_env, call_env = call_env)}
if that \code{optional_steps} element exists.
}
\item After every stratum has been processed, set proper \code{data.table}
attributes on the resulting big table and call \code{data.table::setkeyv}
with \code{cols = c(names(aggre_stratum_dt), "interval_id")}.
\item Run
\code{optional_steps[["post_aggregation"]](eval_env = eval_env, call_env = call_env)}
if that \code{optional_steps} element exists.
\item Return a big \code{data.table} with stratum columns as specified via
\code{aggre_stratum_dt} and value columns as specified via \code{aggre_values_expr}.
}
}

\examples{
# popEpi::surv_merge
lexis <- Epi::Lexis(
  entry = list(ts_fut = 0.0, ts_cal = 2010.3, ts_age = 56.8),
  exit = list(ts_cal = 2024.9999),
  entry.status = 0,
  exit.status = 0
)
lexis$sex <- 0L
lexis <- popEpi::splitMulti(
  data = lexis,
  breaks = list(ts_fut = seq(0, 3, 1 / 12))
)
my_merge_dt <- data.table::CJ(sex = 0:1, ts_age = 0:100, ts_cal = 2000:2025)
data.table::set(
  x = my_merge_dt,
  j = "merge_value",
  value = runif(nrow(my_merge_dt))
)
popEpi::surv_merge(
  dt = lexis,
  merge_dt = my_merge_dt,
  merge_dt_by = c("sex", "ts_age", "ts_cal")
)
stopifnot(
  "merge_value" \%in\% names(lexis),
  !is.na(lexis[["merge_value"]])
)
data.table::set(
  x = lexis,
  j = "merge_value",
  value = NULL
)
popEpi::surv_merge(
  dt = lexis,
  merge_dt = my_merge_dt,
  merge_dt_by = c("sex", "ts_age", "ts_cal"),
  merge_dt_harmonisers = list(
    ts_cal = quote(as.integer(ts_cal)),
    ts_age = quote(as.integer(ts_age))
  )
)
stopifnot(
  "merge_value" \%in\% names(lexis),
  !is.na(lexis[["merge_value"]])
)

}
