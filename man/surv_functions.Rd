% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/wip_surv_estimate.R,
%   R/wip_surv_individual_weights.R, R/wip_surv_lexis.R
\name{surv_estimate}
\alias{surv_estimate}
\alias{surv_individual_weights}
\alias{surv_functions}
\alias{surv_lexis}
\title{Survival Time Statistics}
\usage{
surv_estimate(
  dt,
  ts_fut_col_nm,
  stratum_col_nms = NULL,
  value_col_nms = NULL,
  estimators = "S_pch",
  weights = NULL,
  conf_methods = "log",
  conf_lvls = 0.95
)

surv_individual_weights(dt, standard_weight_dt, observed_weight_dt = NULL)

surv_lexis(
  dt,
  breaks,
  merge_dt_by = NULL,
  merge_dt = NULL,
  merge_dt_harmonisers = NULL,
  aggre_by = NULL,
  aggre_ts_col_nms = NULL,
  aggre_exprs = NULL,
  subset = NULL,
  estimators = "S_pch",
  conf_methods = "log",
  conf_lvls = 0.95,
  weights = NULL
)
}
\arguments{
\item{dt}{\itemize{
\item \code{surv_estimate}: A \code{data.table}.
\item \code{lexis_merge}: A \code{Lexis} dataset (\verb{[Epi::Lexis]}).
\item \code{surv_individual_weights}: A \code{data.frame} / \code{data.table}.
}}

\item{ts_fut_col_nm}{\verb{[character]} (no default)

Name of time scale column over which survival estimates will be computed.
E.g. \code{"ts_fut"}. \code{dt} must contain columns named
\code{paste0(ts_fut_col_nm, "_", c("start", "stop"))}, e.g.
\code{c("ts_fut_start", "ts_fut_stop")}.}

\item{stratum_col_nms}{\verb{[NULL, character]} (default \code{NULL})

Stratum column names in \code{dt}, if any.
\itemize{
\item \code{NULL}: If \code{dt} was the result of calling
\verb{[lexis_split_merge_aggregate_by_stratum]}, then \code{stratum_col_nms} is
taken from the attributes of \code{dt}. If not, this causes no
stratification of output.
\item \code{character}: \code{dt} is stratified by these columns. \code{character(0)} is
also allowed and causes no stratification of output.
}}

\item{value_col_nms}{\verb{[NULL, character]} (default \code{NULL})

Value column names in \code{dt}, if any.
\itemize{
\item \code{NULL}: If \code{dt} was the result of calling
\verb{[lexis_split_merge_aggregate_by_stratum]}, then \code{value_col_nms} is
taken from the attributes of \code{dt}. If not, having this \code{NULL} causes
no value columns from \code{dt} to be included in the output.
\item \code{character}: One or more names of columns in \code{dt} containing values
to be included in the output in addition to the estimate etc. columns.
E.g. \code{value_col_nms = c("n_events", "t_at_risk")}.
}}

\item{estimators}{\verb{[character, list]}
(default \code{"S_pch"})

One or more names of estimators whose estimates will be computed into
\code{dt}.
\itemize{
\item \code{character}: Causes formulae defined internally into \code{popEpi} to be
used to compute the estimates and their standard errors. For available
options see \strong{Details}.
\item \code{list}: Each element must be a list with named elements
\itemize{
\item \code{est}: Quoted (\link{quote}) R expression which when evaluated with
\code{eval(expr, .SD, call_env)} produces the estimates. Here \code{expr}
is the expression, \code{.SD} is the subset of \code{dt} for one stratum, and
\code{call_env} is the environment from which this
functions was called.
\item \code{se}: Also a quoted R expression. This should produce
the standard errors.
}
}}

\item{weights}{Specifies weights to adjust by. What is accepted depends on the function.
See \strong{Details} to understand how the \code{weights} argument is used.
\itemize{
\item \code{popEpi::surv_estimate}: \verb{[data.table, NULL]} (default \code{NULL})
\item \code{popEpi::surv_lexis}: \verb{[data.table, character, NULL]} (default \code{NULL})
}}

\item{conf_methods}{\verb{[character, list]} (default \code{"log"})

Must be of length 1 or \code{length(estimators)}.
Passed one at a time to
\verb{[directadjusting::delta_method_confidence_intervals]}.
Except \code{"none"} causes no confidence intervals to be computed for that
estimator.}

\item{conf_lvls}{\verb{[numeric]} (default \code{0.95})

Must be of length 1 or \code{length(estimators)}.
Passed one at a time to
\verb{[directadjusting::delta_method_confidence_intervals]}.}

\item{standard_weight_dt}{\verb{[data.table]} (no default)

Table of standardisation weights, e.g. ICSS weights.

A table of weights must fulfill these requirements:
\itemize{
\item Is a \code{data.table}.
\item Has at least one stratifying column. No duplicate strata are permitted,
e.g. the same age group twice in a table stratified by age group only.
\item Has column \code{"weight"}. All values must be >= 0. No missing values are
allowed.
}}

\item{observed_weight_dt}{\verb{[NULL, data.table]} (default \code{NULL})

Table of weights in your dataset.
\itemize{
\item \code{NULL}: This is computed based on \code{dt}.
\item \code{data.table}: Must be a valid table of weights.
}

A table of weights must fulfill these requirements:
\itemize{
\item Is a \code{data.table}.
\item Has at least one stratifying column. No duplicate strata are permitted,
e.g. the same age group twice in a table stratified by age group only.
\item Has column \code{"weight"}. All values must be >= 0. No missing values are
allowed.
}}

\item{breaks}{Passed to \verb{[lexis_split_merge_aggregate_by_stratum]}.}

\item{merge_dt_by}{Passed to \verb{[lexis_split_merge_aggregate_by_stratum]}.}

\item{merge_dt}{Passed to \verb{[lexis_split_merge_aggregate_by_stratum]}.}

\item{merge_dt_harmonisers}{Passed to \verb{[lexis_split_merge_aggregate_by_stratum]}.}

\item{aggre_by}{Passed to \verb{[lexis_split_merge_aggregate_by_stratum]}.}

\item{aggre_ts_col_nms}{Passed to \verb{[lexis_split_merge_aggregate_by_stratum]}.}

\item{aggre_exprs}{Passed to \verb{[lexis_split_merge_aggregate_by_stratum]}.}

\item{subset}{Passed to \verb{[lexis_split_merge_aggregate_by_stratum]}.}
}
\value{
\strong{popEpi::surv_estimate}

Returns \code{dt} invisibly after adding new columns depending on argument
\code{estimators}.
You don't need to keep the output of \code{popEpi::surv_estimate} because it
modifies \code{dt} in place.

\strong{popEpi::surv_individual_weights}

A vector of weights is returned.

\strong{popEpi::surv_lexis}

Returns a \code{data.table} as produced by \code{surv_estimate}.
}
\description{
Functions used for estimation of various survival time statistics.
E.g. relative survival.
}
\section{Functions}{

\strong{popEpi::surv_estimate}

Compute survival time function estimates. Performs the following steps:
\itemize{
\item Handles \code{estimators}. Elements of \code{estimators} that are character
strings cause the corresponding pre-defined formulae to be used.
E.g. \code{"S_pch"}.
Pre-defined estimators with their formulae:
}\tabular{lll}{
   Name of estimator \tab est \tab se \cr
   \verb{h_pch} \tab \verb{n_events/t_at_risk} \tab \verb{sqrt(n_events/t_at_risk/t_at_risk)} \cr
   \verb{H_pch} \tab \verb{cumsum(delta_t * (n_events/t_at_risk))} \tab \verb{sqrt(cumsum(delta_t^2 * sqrt(n_events/t_at_risk/t_at_risk)^2))} \cr
   \verb{h_exp_e2_pch} \tab \verb{n_events_exp_e2/t_at_risk} \tab \verb{0 + 0} \cr
   \verb{h_exc_e2_pch} \tab \verb{(n_events - n_events_exp_e2)/t_at_risk} \tab \verb{sqrt(n_events/t_at_risk/t_at_risk)} \cr
   \verb{S_pch} \tab \verb{exp(-cumsum(delta_t * (n_events/t_at_risk)))} \tab \verb{exp(-cumsum(delta_t * (n_events/t_at_risk))) * sqrt(cumsum((delta_t^2) * n_events/(t_at_risk^2)))} \cr
   \verb{F_pch} \tab \verb{1 - exp(-cumsum(delta_t * (n_events/t_at_risk)))} \tab \verb{exp(-cumsum(delta_t * (n_events/t_at_risk))) * sqrt(cumsum((delta_t^2) * n_events/(t_at_risk^2)))} \cr
   \verb{S_lt} \tab \verb{cumprod(1 - n_events/n_at_risk_eff)} \tab \verb{cumprod(1 - n_events/n_at_risk_eff) * sqrt(cumsum(n_events/(n_at_risk_eff * (n_at_risk_eff - n_events))))} \cr
   \verb{H_lt} \tab \verb{-log(cumprod(1 - n_events/n_at_risk_eff))} \tab \verb{0 + NA_real_} \cr
   \verb{h_lt} \tab \verb{diff(c(0, -log(cumprod(1 - n_events/n_at_risk_eff))))/delta_t} \tab \verb{0 + NA_real_} \cr
   \verb{F_lt} \tab \verb{1 - cumprod(1 - n_events/n_at_risk_eff)} \tab \verb{cumprod(1 - n_events/n_at_risk_eff) * sqrt(cumsum(n_events/(n_at_risk_eff * (n_at_risk_eff - n_events))))} \cr
   \verb{S_exp_e2_lt} \tab \verb{cumprod(1 - n_events_exp_e2/n_at_risk_eff)} \tab \verb{0 + 0} \cr
   \verb{S_exp_e2_pch} \tab \verb{exp(-cumsum(delta_t * (n_events_exp_e2/t_at_risk)))} \tab \verb{0 + 0} \cr
   \verb{RS_e2_lt} \tab \verb{cumprod(1 - (n_events - n_events_exp_e2)/n_at_risk_eff)} \tab \verb{cumprod(1 - n_events/n_at_risk_eff) * sqrt(cumsum(n_events/(n_at_risk_eff * (n_at_risk_eff - n_events))))/cumprod(1 - n_events_exp_e2/n_at_risk_eff)} \cr
   \verb{RS_e2_pch} \tab \verb{exp(-cumsum(delta_t * ((n_events - n_events_exp_e2)/t_at_risk)))} \tab \verb{exp(-cumsum(delta_t * (n_events/t_at_risk))) * sqrt(cumsum((delta_t^2) * n_events/(t_at_risk^2)))/exp(-cumsum(delta_t * (n_events_exp_e2/t_at_risk)))} \cr
   \verb{NS_pp_lt} \tab \verb{cumprod(1 - (n_events_pp - n_events_exp_pp)/n_at_risk_eff_pp)} \tab \verb{cumprod(1 - (n_events_pp - n_events_exp_pp)/n_at_risk_eff_pp) * sqrt(cumsum(n_events_pp_double_weighted/(n_at_risk_eff^2)))} \cr
   \verb{NS_pp_pch} \tab \verb{exp(-cumsum(delta_t * (n_events_pp - n_events_exp_pp)/t_at_risk_pp))} \tab \verb{exp(-cumsum(delta_t * (n_events_pp - n_events_exp_pp)/t_at_risk_pp)) * sqrt(cumsum((delta_t^2) * n_events_pp_double_weighted/(t_at_risk_pp^2)))} \cr
   \verb{h_lt_[x, y]} \tab \verb{-log(1 - `n_events_[x, y]`/n_at_risk_eff)} \tab \verb{0 + NA_real_} \cr
   \verb{h_pch_[x, y]} \tab \verb{`n_events_[x, y]`/t_at_risk} \tab \verb{sqrt(`n_events_[x, y]`/t_at_risk/t_at_risk)} \cr
   \verb{H_lt_[x, y]} \tab \verb{-log(cumprod(1 - `n_events_[x, y]`/n_at_risk_eff))} \tab \verb{0 + NA_real_} \cr
   \verb{H_pch_[x, y]} \tab \verb{cumsum(delta_t * (`n_events_[x, y]`/t_at_risk))} \tab \verb{sqrt(cumsum(delta_t^2 * sqrt(`n_events_[x, y]`/t_at_risk/t_at_risk)^2))} \cr
   \verb{S_lt_[x, y]} \tab \verb{cumprod(1 - `n_events_[x, y]`/n_at_risk_eff)} \tab \verb{cumprod(1 - `n_events_[x, y]`/n_at_risk_eff) * sqrt(cumsum(`n_events_[x, y]`/(n_at_risk_eff * (n_at_risk_eff - `n_events_[x, y]`))))} \cr
   \verb{S_pch_[x, y]} \tab \verb{exp(-cumsum(delta_t * (`n_events_[x, y]`/t_at_risk)))} \tab \verb{exp(-cumsum(delta_t * (n_events/t_at_risk))) * sqrt(cumsum((delta_t^2) * `n_events_[x, y]`/(t_at_risk^2)))} \cr
   \verb{F_lt_[x, y]} \tab \verb{{;     q <- (1 - (1 - (n_events/n_at_risk_eff))) * `n_events_[x, y]`/n_events;     q[n_events == 0] <- 0;     cumsum(c(1, cumprod(1 - (n_events/n_at_risk_eff))[-length(n_events)]) * q); }} \tab \verb{0 + NA_real_} \cr
   \verb{F_pch_[x, y]} \tab \verb{{;     q <- (1 - exp(-delta_t * (n_events/t_at_risk))) * `n_events_[x, y]`/n_events;     q[n_events == 0] <- 0;     cumsum(c(1, exp(-cumsum(delta_t * (n_events/t_at_risk)))[-length(delta_t)]) * q); }} \tab \verb{0 + NA_real_} \cr
   \verb{RF_e2_lt} \tab \verb{{;     q <- (1 - (1 - (n_events/n_at_risk_eff))) * (n_events - n_events_exp_e2)/n_events;     q[n_events == 0] <- 0;     cumsum(c(1, cumprod(1 - (n_events/n_at_risk_eff))[-length(n_events)]) * q); }} \tab \verb{0 + NA_real_} \cr
   \verb{RF_e2_pch} \tab \verb{{;     q <- (1 - exp(-delta_t * (n_events/t_at_risk))) * (n_events - n_events_exp_e2)/n_events;     q[n_events == 0] <- 0;     cumsum(c(1, exp(-cumsum(delta_t * (n_events/t_at_risk)))[-length(delta_t)]) * q); }} \tab \verb{0 + NA_real_} \cr
   \verb{F_exp_e2_lt} \tab \verb{1 - cumprod(1 - n_events_exp_e2/n_at_risk_eff)} \tab \verb{0 + 0} \cr
   \verb{F_exp_e2_pch} \tab \verb{1 - exp(-cumsum(delta_t * (n_events_exp_e2/t_at_risk)))} \tab \verb{0 + 0} \cr
   \verb{F_exc_e2_lt} \tab \verb{F_lt - F_exp_e2_lt} \tab \verb{cumprod(1 - n_events/n_at_risk_eff) * sqrt(cumsum(n_events/(n_at_risk_eff * (n_at_risk_eff - n_events))))} \cr
   \verb{F_exc_e2_pch} \tab \verb{F_pch - F_exp_e2_pch} \tab \verb{exp(-cumsum(delta_t * (n_events/t_at_risk))) * sqrt(cumsum((delta_t^2) * n_events/(t_at_risk^2)))} \cr
   \verb{S_exp_e1_pch} \tab \verb{surv_lexis_S_exp_e1_pch_est(dt = surv_lexis_env[["dt"]], breaks = surv_lexis_env[["breaks"]], ts_fut_col_nm = surv_lexis_env[["ts_fut_col_nm"]], merge_dt = surv_lexis_env[["merge_dt"]], merge_dt_by = surv_lexis_env[["merge_dt_by"]], weight_col_nm = surv_lexis_env[["weight_col_nm"]])} \tab \verb{0 + 0} \cr
   \verb{F_exp_e1_pch} \tab \verb{1 - surv_lexis_S_exp_e1_pch_est(dt = surv_lexis_env[["dt"]], breaks = surv_lexis_env[["breaks"]], ts_fut_col_nm = surv_lexis_env[["ts_fut_col_nm"]], merge_dt = surv_lexis_env[["merge_dt"]], merge_dt_by = surv_lexis_env[["merge_dt_by"]], weight_col_nm = surv_lexis_env[["weight_col_nm"]])} \tab \verb{0 + 0} \cr
   \verb{F_extra_e1_pch} \tab \verb{1 - exp(-cumsum(delta_t * (n_events/t_at_risk))) - (1 - surv_lexis_S_exp_e1_pch_est(dt = surv_lexis_env[["dt"]], breaks = surv_lexis_env[["breaks"]], ts_fut_col_nm = surv_lexis_env[["ts_fut_col_nm"]], merge_dt = surv_lexis_env[["merge_dt"]], merge_dt_by = surv_lexis_env[["merge_dt_by"]], weight_col_nm = surv_lexis_env[["weight_col_nm"]]))} \tab \verb{exp(-cumsum(delta_t * (n_events/t_at_risk))) * sqrt(cumsum((delta_t^2) * n_events/(t_at_risk^2)))} \cr
   \verb{S_exp_e1_pch} \tab \verb{surv_lexis_S_exp_e1_pch_est(dt = surv_lexis_env[["dt"]], breaks = surv_lexis_env[["breaks"]], ts_fut_col_nm = surv_lexis_env[["ts_fut_col_nm"]], merge_dt = surv_lexis_env[["merge_dt"]], merge_dt_by = surv_lexis_env[["merge_dt_by"]], weight_col_nm = surv_lexis_env[["weight_col_nm"]])} \tab \verb{0 + 0} \cr
   \verb{S_def_e1_pch} \tab \verb{surv_lexis_S_exp_e1_pch_est(dt = surv_lexis_env[["dt"]], breaks = surv_lexis_env[["breaks"]], ts_fut_col_nm = surv_lexis_env[["ts_fut_col_nm"]], merge_dt = surv_lexis_env[["merge_dt"]], merge_dt_by = surv_lexis_env[["merge_dt_by"]], weight_col_nm = surv_lexis_env[["weight_col_nm"]]) - exp(-cumsum(delta_t * (n_events/t_at_risk)))} \tab \verb{exp(-cumsum(delta_t * (n_events/t_at_risk))) * sqrt(cumsum((delta_t^2) * n_events/(t_at_risk^2)))} \cr
}

\itemize{
\item Armed with a list of expressions based on \code{estimates}, called
\code{expressions}, for each \code{i}:
\itemize{
\item Evaluate each element of \code{expressions[[i]]} and add the result into
\code{dt}. E.g. \code{S_pch_est} and
\code{S_pch_se}.
\item If \code{conf_methods[[i]]} is not \code{"none"}, compute confidence intervals
by calling \verb{[directadjusting::delta_method_confidence_intervals]}
and add them into \code{dt}.
}
\item If \code{weights} was a \code{data.table}, we perform an additional direct
adjusting step by calling
\verb{[directadjusting::directly_adjusted_estimates]}.
\item If \code{weights} was a \code{data.table}, the summary statistics such as
\code{n_events} are summed over the adjusting strata and will be included
in the output. These are not weighted averages/sums but simple sums.
\item Return \code{dt} invisibly.
}


\strong{popEpi::surv_individual_weights}

Produce a vector of weights, one weight for each row in \code{dt}.
These weights have been called individual weights, Brenner weights,
(Brenner et al 2004, https://doi.org/10.1016/j.ejca.2004.07.007),
pre-weights, and maybe even others. A beloved child has many names.

The idea of these weights is to weigh the individual contribution of each
person to the summary statistics from which the survival function estimates
themselves are produced. They pronounce the influence of under-represented
data and reduce the influence of over-represented data just as the more
conventional computation of weighted averages survival function estimates
does. However, in this individual weighting approach even a single event
can be included in the summary statistics as e.g. 0.80 or 1.20 events
for over and under-represented data respectively.

This function makes producing these weights easier. It performs the
following steps:
\itemize{
\item If \code{is.null(observed_weight_dt)}, \code{observed_weight_dt} is computed
by \code{surv_individual_weights} by simply counting the number of cases
in each stratum in \code{standard_weight_dt}.
\item Merge \code{standard_weight_dt} and \code{observed_weight_dt} into one table.
Scale the standard weights and the observed weights to sum into one
(they are in separate columns). E.g. one stratum has
\code{weight_standard = 0.5} and \code{weight_observed = 0.4}.
\item Compute the individual weights as the standard weights divided by the
observed weights. E.g. one stratum has
\code{weight_brenner = 0.5 / 0.4 = 1.2}.
\item Using left-join, produce a vector of length \code{nrow(dt)} where each row in
\code{dt} gets an individual weight based on its stratum.
A vector of weights is returned.
}


\strong{popEpi::surv_lexis}

Compute survival estimates on a \code{Lexis} dataset (\verb{[Epi::Lexis]}).

Performs the following steps:
\itemize{
\item \code{estimators} is analysed and the following will be appended to
\code{aggre_exprs}by \code{surv_lexis}:
\itemize{
\item Detect variables used in the estimation expressions with \verb{[all.vars]}.
\item Retain only those known to \code{popEpi} --- see
\code{?lexis_split_merge_aggregate_by_stratum}. This results in a character
string vector that the argument \code{aggre_exprs} of
\code{lexis_split_merge_aggregate_by_stratum} accepts.
}
\item This results in \code{aggre_exprs} with both anything that the user defined
and also what was added by \code{surv_lexis}. However, we drop duplicates
in \code{aggre_exprs} based on both \code{duplicated(names(aggre_exprs))} and
\code{duplicated(aggre_exprs)}. E.g. if you supply
\code{aggre_exprs = list(n_events = quote(sum(lex.Xst != 0)))}
and \code{n_events} is also added by \code{surv_lexis} then only the one you
supplied is retained.
\item Call \code{lexis_split_merge_aggregate_by_stratum}.
The resulting table of aggregated data is
stratified by both \code{aggre_by} and by any stratifying columns found in
\code{weights} if a \code{data.table} was supplied as that argument. E.g.
with \code{aggre_by = "sex"} and
\code{weights = data.table::data.table(ag = 1:3, weight = c(100, 150, 200))},
the statistics table is stratified by both \code{sex} and \code{ag}.
With \code{aggre_by = "sex"} and \code{weights = "individual_weight"} the table is
stratified by sex and contains individually weighted statistics.
\item Call \code{surv_estimate}.
}
}

\section{News for version 0.5.0}{


New function \code{surv_estimate} for estimating arbitrary survival time
functions using aggregated data.
}

\examples{

# popEpi::surv_estimate
dt <- data.table::data.table(
  ts_fut_start = seq(0, 5 - 1 / 12, 1 / 12),
  ts_fut_stop = seq(1 / 12, 5, 1 / 12),
  n_events = rpois(n = 60, lambda = 60:1),
  t_at_risk = rpois(n = 60, lambda = 300:240)
)
data.table::set(
  x = dt,
  j = "my_h_pch",
  value = dt[["n_events"]] / dt[["t_at_risk"]]
)
sdt <- popEpi::surv_estimate(
  dt = dt,
  ts_fut_col_nm = "ts_fut",
  value_col_nms = c("n_events", "t_at_risk"),
  estimators = c("h_pch", "S_pch"),
  conf_methods = "log-log"
)
stopifnot(
  c("h_pch_est", "S_pch_est") \%in\% names(sdt),
  dt[["my_h_pch"]] == sdt[["h_pch_est"]]
)
sdt <- popEpi::surv_estimate(
  dt = dt,
  ts_fut_col_nm = "ts_fut",
  value_col_nms = c("n_events", "t_at_risk"),
  estimators = list(
    "h_pch",
    my_surv = list(
      est = quote(
        exp(-cumsum((ts_fut_stop - ts_fut_start) * h_pch_est))
      ),
      se = quote(rep(0.0, length(ts_fut_start)))
    )
  ),
  conf_methods = c("log", "none")
)
stopifnot(
  c("h_pch_est", "my_surv_est") \%in\% names(sdt)
)
sdt <- popEpi::surv_estimate(
  dt = dt,
  ts_fut_col_nm = "ts_fut",
  value_col_nms = c("n_events", "t_at_risk"),
  estimators = list(
    "h_pch",
    "S_pch"
  ),
  conf_methods = list(
    "log",
    list(
      g = quote(stats::qnorm(p = theta)),
      g_inv = quote(stats::pnorm(q = g))
    )
  )
)
stopifnot(
  c("h_pch_est", "S_pch_est") \%in\% names(sdt)
)

}
