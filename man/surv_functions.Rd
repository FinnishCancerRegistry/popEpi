% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/wip_surv_estimate.R,
%   R/wip_surv_individual_weights.R, R/wip_surv_lexis.R, R/wip_surv_merge.R,
%   R/wip_surv_split_merge_aggregate.R
\name{surv_estimate}
\alias{surv_estimate}
\alias{surv_individual_weights}
\alias{surv_functions}
\alias{surv_lexis}
\alias{surv_merge}
\alias{surv_split_merge_aggregate_by_stratum}
\title{Survival Time Statistics}
\usage{
surv_estimate(
  dt,
  ts_fut_col_nm,
  stratum_col_nms = NULL,
  value_col_nms = NULL,
  estimators = "s_pch",
  weights = NULL,
  conf_methods = "log",
  conf_lvls = 0.95
)

surv_individual_weights(dt, standard_weight_dt, observed_weight_dt = NULL)

surv_lexis(
  dt,
  breaks,
  merge_dt_by = NULL,
  merge_dt = NULL,
  merge_dt_harmonisers = NULL,
  aggre_by = NULL,
  aggre_ts_col_nms = NULL,
  aggre_expr = NULL,
  subset = NULL,
  estimators = "s_pch",
  conf_methods = "log",
  conf_lvls = 0.95,
  weights = NULL
)

surv_merge(
  dt,
  merge_dt,
  merge_dt_by,
  merge_dt_harmonisers = NULL,
  merge_dt_default_harmoniser_lex_dur_multiplier = 0.5,
  optional_steps = NULL
)

surv_split_merge_aggregate_by_stratum(
  dt,
  breaks,
  merge_dt = NULL,
  merge_dt_by = NULL,
  merge_dt_harmonisers = NULL,
  aggre_by = NULL,
  aggre_ts_col_nms = NULL,
  aggre_expr,
  subset = NULL,
  optional_steps = NULL
)
}
\arguments{
\item{dt}{\itemize{
\item \code{surv_estimate}: A \code{data.table}.
\item \code{surv_individual_weights}: A \code{data.frame} / \code{data.table}.
\item \code{surv_merge}: A \code{Lexis} dataset (\verb{[Epi::Lexis]}).
\item \code{surv_split_merge_aggregate_by_stratum}:
A \code{Lexis} dataset (\verb{[Epi::Lexis]}).
}}

\item{ts_fut_col_nm}{\verb{[character]} (no default)

Name of time scale column over which survival estimates will be computed.
E.g. \code{"ts_fut"}. \code{dt} must contain columns named
\code{paste0(ts_fut_col_nm, "_", c("start", "stop"))}, e.g.
\code{c("ts_fut_start", "ts_fut_stop")}.}

\item{stratum_col_nms}{\verb{[NULL, character]} (default \code{NULL})

Stratum column names in \code{dt}, if any.
\itemize{
\item \code{NULL}: If \code{dt} was the result of calling
\verb{[surv_split_merge_aggregate_by_stratum]}, then \code{stratum_col_nms} is
taken from the attributes of \code{dt}. If not, this causes no
stratification of output.
\item \code{character}: \code{dt} is stratified by these columns. \code{character(0)} is
also allowed and causes no stratification of output.
}}

\item{value_col_nms}{\verb{[NULL, character]} (default \code{NULL})

Value column names in \code{dt}, if any.
\itemize{
\item \code{NULL}: If \code{dt} was the result of calling
\verb{[surv_split_merge_aggregate_by_stratum]}, then \code{value_col_nms} is
taken from the attributes of \code{dt}. If not, having this \code{NULL} causes
no value columns from \code{dt} to be included in the output.
\item \code{character}: One or more names of columns in \code{dt} containing values
to be included in the output in addition to the estimate etc. columns.
E.g. \code{value_col_nms = c("n_events", "t_at_risk")}.
}}

\item{estimators}{\verb{[character, list]}
(default \code{"s_pch"})

One or more names of estimators whose estimates will be computed into
\code{dt}.
\itemize{
\item \code{character}: Causes formulae defined internally into \code{popEpi} to be
used to compute the estimates and their standard errors. For available
options see \strong{Details}.
\item \code{list}: Each element must be a list with named elements
\itemize{
\item \code{estimate}: Quoted (\link{quote}) R expression which when evaluated with
\code{eval(expr, .SD, call_env)} produces the estimates. Here \code{expr}
is the expression, \code{.SD} is the subset of \code{dt} for one stratum, and
\code{call_env} is the environment from which this
functions was called.
\item \code{standard_error}: Also a quoted R expression. This should produce
the standard errors.
}
}}

\item{weights}{Specifies weights to adjust by. What is accepted depends on the function.
See \strong{Details} to understand how the \code{weights} argument is used.
\itemize{
\item \code{popEpi::surv_estimate}: \verb{[data.table, NULL]} (default \code{NULL})
\item \code{popEpi::surv_lexis}: \verb{[data.table, character, NULL]} (default \code{NULL})
}}

\item{conf_methods}{\verb{[character, list]} (default \code{"log"})

Must be of length 1 or \code{length(estimators)}.
Passed one at a time to
\verb{[directadjusting::delta_method_confidence_intervals]}.
Except \code{"none"} causes no confidence intervals to be computed for that
estimator.}

\item{conf_lvls}{\verb{[numeric]} (default \code{0.95})

Must be of length 1 or \code{length(estimators)}.
Passed one at a time to
\verb{[directadjusting::delta_method_confidence_intervals]}.}

\item{standard_weight_dt}{\verb{[data.table]} (no default)

Table of standardisation weights, e.g. ICSS weights.

A table of weights must fulfill these requirements:
\itemize{
\item Is a \code{data.table}.
\item Has at least one stratifying column. No duplicate strata are permitted,
e.g. the same age group twice in a table stratified by age group only.
\item Has column \code{"weight"}. All values must be >= 0. No missing values are
allowed.
}}

\item{observed_weight_dt}{\verb{[NULL, data.table]} (default \code{NULL})

Table of weights in your dataset.
\itemize{
\item \code{NULL}: This is computed based on \code{dt}.
\item \code{data.table}: Must be a valid table of weights.
}

A table of weights must fulfill these requirements:
\itemize{
\item Is a \code{data.table}.
\item Has at least one stratifying column. No duplicate strata are permitted,
e.g. the same age group twice in a table stratified by age group only.
\item Has column \code{"weight"}. All values must be >= 0. No missing values are
allowed.
}}

\item{breaks}{\verb{[list]} (no default)

List of breaks to split \code{Lexis} data by. Passed to \verb{[splitMulti]}.
E.g. \code{list(ts_fut = seq(0, 5, 1 / 12), ts_cal = c(2001, 2006))}.}

\item{merge_dt_by}{\verb{[character, NULL]} (no default or default \code{NULL})

Names of columns in both \code{merge_dt} and \code{dt} by which \code{merge_dt} will be
merged with \code{ dt}.
\itemize{
\item \code{NULL}: Allowed only if this is the function's default for this argument.
When both \code{merge_dt} and \code{merge_dt_by} are \code{NULL}, no merge is performed.
\item \code{character}: Use these columns.
}}

\item{merge_dt}{\verb{[data.table, NULL]} (no default or default \code{NULL})

A \code{data.table} to merge with \code{dt}, possibly after splitting.
\itemize{
\item \code{NULL}: Allowed only if this is the function's default for this argument.
When both \code{merge_dt} and \code{merge_dt_by} are \code{NULL}, no merge is performed.
\item \code{data.table}: Merge this table. Typically this contains the
expected hazards for the estimation of relative or net survival.
}}

\item{merge_dt_harmonisers}{\verb{[NULL, list]} (default \code{NULL})

Optional list of quoted expressions which, when evaluated, harmonise
data in \code{dt} (possibly after splitting) to look the same as the data in
\code{merge_dt}. For example, if \code{merge_dt} contains expected hazards by
calendar year \code{ts_cal} and 1-year age group \code{ts_age}, and if \code{dt} has been
split into monthly survival intervals, then we must somehow find the
correct row in \code{merge_dt} for each row in \code{dt}. E.g. \code{ts_cal = 2010.5323}
and \code{ts_age = 76.4435} need to be harmonised into values found in
\code{merge_dt} such as \code{ts_cal = 2010} and \code{ts_age = 76}.
\itemize{
\item \code{NULL}: This function comes up with reasonable harmonisers if possible.
See \strong{Details}.
\item \code{list}: Each element must a quoted expression (\verb{[quote]}) and each
element must have a name corresponding to a column name in both \code{dt}
and \code{merge_dt}. See \strong{Examples}.
}}

\item{aggre_by}{\verb{[data.table, character, list, NULL]} (default \code{NULL})
\itemize{
\item \code{NULL}: No stratification of output.
\item \code{data.table}: Compute produce results for each stratum defined in this
table, e.g. \code{data.table::data.table(sex = 1:2)}. You may even use this to
take a subset at the same time by doing
e.g. \code{data.table::data.table(sex = 1L)} even if your \code{dt} contains data
for both sexes.
\item \code{character}: Compute results for each stratum defined by these columns
in \code{dt}. E.g. \code{"sex"}.
\item \code{list}: Each element must be either a \code{data.table}, a \code{character} vector,
or \code{NULL}. These are combined to yield a big \code{data.table}. E.g.
\code{list("sex", data.table::data.table(ag = 1:18))} leading to the same as
\code{data.table::CJ(sex = 1:2, ag = 1:18)}.
}}

\item{aggre_ts_col_nms}{\verb{[NULL, character]} (default \code{NULL})

Names of \code{Lexis} time scales in \code{dt} by which to aggregate results.
\itemize{
\item \code{NULL}: Use \code{names(breaks)}.
\item \code{character}: Aggregate by these time scales. E.g. \code{"ts_fut"}.
}}

\item{aggre_expr}{\verb{[call]} (no default)

A quoted (\verb{[quote]}) R expression. When this is evaluated within a stratum,
the desired summary statistics are produced for that stratum. One
evaluation stratum is based on \code{aggre_by} and \code{aggre_ts_col_nms}, and might
be e.g. \code{list(sex = 1, ag = 6, ts_fut_start = 3.0, ts_fut_stop = 4.0)}
with \code{aggre_by = c("sex", "ag")} and \code{aggre_ts_col_nms = "ts_fut"}.
The data
for the stratum have been split and \code{merge_dt} has been merged when
\code{aggre_expr} is evaluated. E.g.
\code{quote(list(n_at_risk = sum(at_risk), n_events = sum(lex.Cst != lex.Xst)))}
. See \strong{Details} for what kinds of expressions are possible.
\itemize{
\item \code{NULL}: Use \code{names(breaks)}.
\item \code{character}: Aggregate by these time scales. E.g. \code{"ts_fut"}.
}}

\item{subset}{\verb{[NULL, logical, integer, data.table]} (default \code{NULL})

This argument is evaluated within the context of \code{dt} and the environment
where the function with this argument was called.
\itemize{
\item \code{NULL}: Implies no subsetting, i.e. retain all observations.
\item \code{logical}: Keep only observations where this is \code{TRUE}. Must be of length
\code{nrow(dt)}. E.g. \code{subset = my_column == 1.}
\item \code{integer}: Keep only observations at these row numbers. E.g.
\code{subset = 1:5}.
\item \code{data.table}: Each column must also be a column of \code{dt}. Only those rows
in \code{dt} are retained that match a row in \code{subset}. E.g.
\code{subset = data.table::data.table(my_column = 1)}.
}

Due to the non-standard evaluation method used here, you can make use of
data in the calling environment as well. E.g. with variable \code{my_value = 1}
defined and \code{dt} containing column \code{my_column} you can do
\code{subset = my_column == my_value} if you want.}

\item{merge_dt_default_harmoniser_lex_dur_multiplier}{\verb{[numeric]}
(default 0.5)

The default 0.5 causes such default harmonisers to be created that
each record's each time scale is used at the middle of the observed
record. E.g. with \code{ts_age = 55.9} and \code{lex.dur = 0.6} we arrive at
\code{ts_age = 55.9 + 0.6 * 0.2 = 56.2}, which is then harmonised with \code{cut}
to \code{ts_age = 56} for the purpose of merging with \code{merge_dt}. The
middle of the record is a rational choice when a record covers multiple
strata of \code{merge_dt}, at least when merging population expected
hazards.}

\item{optional_steps}{\verb{[NULL, list]} (default \code{NULL})

Optional steps to perform along the way.
\itemize{
\item \code{NULL}: No optional steps are performed.
\item \code{list}: Each named element is a function that is called in a specific
stage of the run. See \strong{Details} for what functions are recognised.
}}
}
\value{
\strong{popEpi::surv_estimate}

Returns \code{dt} invisibly after adding new columns depending on argument
\code{estimators}.
You don't need to keep the output of \code{popEpi::surv_estimate} because it
modifies \code{dt} in place.

\strong{popEpi::surv_individual_weights}

A vector of weights is returned.

\strong{popEpi::surv_lexis}

A \code{data.table} of summary statistics and survival estimates with their
standard errors and confidence intervals is returned.

\strong{popEpi::surv_merge}

Returns \code{dt} invisibly after adding columns from
\code{merge_dt} into \code{dt} in-place, without taking a copy.

\strong{popEpi::surv_split_merge_aggregate_by_stratum}

Returns a \code{data.table} with stratum columns as specified via
\code{aggre_by} and value columns as specified via \code{aggre_expr}.
}
\description{
Functions used for estimation of various survival time statistics.
E.g. relative survival.
}
\section{Functions}{

\strong{popEpi::surv_estimate}

Compute survival time function estimates. Performs the following steps:
\itemize{
\item Handles \code{estimators}. Elements of \code{estimators} that are character
strings cause the corresponding pre-defined formulae to be used.
E.g. \code{"s_pch"}.
Pre-defined estimators with their formulae:
}\tabular{lll}{
   Name of estimator \tab est \tab se \cr
   \verb{h_pch} \tab \verb{n_events/t_at_risk} \tab \verb{sqrt(n_events/t_at_risk/t_at_risk)} \cr
   \verb{ch_pch} \tab \verb{cumsum(delta_t * (n_events/t_at_risk))} \tab \verb{sqrt(cumsum(delta_t^2 * sqrt(n_events/t_at_risk/t_at_risk)^2))} \cr
   \verb{h_lt} \tab \verb{-log(1 - n_events/n_at_risk_eff)} \tab \verb{0 + NA_real_} \cr
   \verb{ch_lt} \tab \verb{cumsum(delta_t * -log(1 - n_events/n_at_risk_eff))} \tab \verb{0 + NA_real_} \cr
   \verb{h_exp_e2_pch} \tab \verb{n_events_exp_e2/t_at_risk} \tab \verb{0 + 0} \cr
   \verb{h_exc_e2_pch} \tab \verb{(n_events - n_events_exp_e2)/t_at_risk} \tab \verb{sqrt(n_events/t_at_risk/t_at_risk)} \cr
   \verb{s_lt} \tab \verb{cumprod(1 - n_events/n_at_risk_eff)} \tab \verb{cumprod(1 - n_events/n_at_risk_eff) * sqrt(cumsum(n_events/(n_at_risk_eff * (n_at_risk_eff - n_events))))} \cr
   \verb{s_pch} \tab \verb{exp(-cumsum(delta_t * (n_events/t_at_risk)))} \tab \verb{exp(-cumsum(delta_t * (n_events/t_at_risk))) * sqrt(cumsum((delta_t^2) * n_events/(t_at_risk^2)))} \cr
   \verb{s_exp_e2_lt} \tab \verb{cumprod(1 - n_events_exp_e2/n_at_risk_eff)} \tab \verb{rep(0, length(cumprod(1 - n_events_exp_e2/n_at_risk_eff)))} \cr
   \verb{s_exp_e2_pch} \tab \verb{exp(-cumsum(delta_t * (n_events_exp_e2/t_at_risk)))} \tab \verb{rep(0, length(n_events_exp_e2/t_at_risk))} \cr
   \verb{rs_e2_lt} \tab \verb{cumprod(1 - (n_events - n_events_exp_e2)/n_at_risk_eff)} \tab \verb{cumprod(1 - n_events/n_at_risk_eff) * sqrt(cumsum(n_events/(n_at_risk_eff * (n_at_risk_eff - n_events))))/cumprod(1 - n_events_exp_e2/n_at_risk_eff)} \cr
   \verb{rs_e2_pch} \tab \verb{exp(-cumsum(delta_t * ((n_events - n_events_exp_e2)/t_at_risk)))} \tab \verb{exp(-cumsum(delta_t * (n_events/t_at_risk))) * sqrt(cumsum((delta_t^2) * n_events/(t_at_risk^2)))/exp(-cumsum(delta_t * (n_events_exp_e2/t_at_risk)))} \cr
   \verb{ns_pp_lt} \tab \verb{cumprod(1 - (n_events_pp - n_events_exp_pp)/n_in_follow_up_eff_pp)} \tab \verb{cumprod(1 - (n_events_pp - n_events_exp_pp)/n_in_follow_up_eff_pp) * sqrt(cumsum(n_events_pp_double_weighted/(n_at_risk_eff^2)))} \cr
   \verb{ns_pp_pch} \tab \verb{exp(-cumsum(delta_t * ((n_events_pp - n_events_exp_pp)/t_at_risk_pp)))} \tab \verb{exp(-cumsum(delta_t * ((n_events_pp - n_events_exp_pp)/t_at_risk_pp))) * sqrt(cumsum((delta_t^2) * n_events_pp_double_weighted/(t_at_risk_pp^2)))} \cr
   \verb{h_lt_[x, y]} \tab \verb{-log(1 - `n_events_[x, y]`/n_at_risk_eff)} \tab \verb{0 + NA_real_} \cr
   \verb{h_pch_[x, y]} \tab \verb{`n_events_[x, y]`/t_at_risk} \tab \verb{sqrt(`n_events_[x, y]`/t_at_risk/t_at_risk)} \cr
   \verb{ch_lt_[x, y]} \tab \verb{-log(cumprod(1 - `n_events_[x, y]`/n_at_risk_eff))} \tab \verb{0 + NA_real_} \cr
   \verb{ch_pch_[x, y]} \tab \verb{cumsum(delta_t * (`n_events_[x, y]`/t_at_risk))} \tab \verb{sqrt(cumsum(delta_t^2 * sqrt(`n_events_[x, y]`/t_at_risk/t_at_risk)^2))} \cr
   \verb{s_lt_[x, y]} \tab \verb{cumprod(1 - `n_events_[x, y]`/n_at_risk_eff)} \tab \verb{cumprod(1 - `n_events_[x, y]`/n_at_risk_eff) * sqrt(cumsum(`n_events_[x, y]`/(n_at_risk_eff * (n_at_risk_eff - `n_events_[x, y]`))))} \cr
   \verb{s_pch_[x, y]} \tab \verb{exp(-`ch_pch_[x, y]`)} \tab \verb{exp(-cumsum(delta_t * (n_events/t_at_risk))) * sqrt(cumsum((delta_t^2) * `n_events_[x, y]`/(t_at_risk^2)))} \cr
   \verb{ar_lt_[x, y]} \tab \verb{{;     q <- (1 - (1 - (n_events/n_at_risk_eff))) * `n_events_[x, y]`/n_events;     q[n_events == 0] <- 0;     cumsum(c(1, cumprod(1 - (n_events/n_at_risk_eff))[-length(1 - (n_events/n_at_risk_eff))]) * q); }} \tab \verb{0 + NA_real_} \cr
   \verb{ar_pch_[x, y]} \tab \verb{{;     q <- (1 - exp(-delta_t * (n_events/t_at_risk))) * `n_events_[x, y]`/n_events;     q[n_events == 0] <- 0;     cumsum(c(1, exp(-cumsum(delta_t * (n_events/t_at_risk)))[-length(n_events/t_at_risk)]) * q); }} \tab \verb{0 + NA_real_} \cr
   \verb{er_e2_lt} \tab \verb{{;     q <- (1 - (1 - (n_events/n_at_risk_eff))) * (n_events - n_events_exp_e2)/n_events;     q[n_events == 0] <- 0;     cumsum(c(1, cumprod(1 - (n_events/n_at_risk_eff))[-length(1 - (n_events/n_at_risk_eff))]) * q); }} \tab \verb{0 + NA_real_} \cr
   \verb{er_e2_pch} \tab \verb{{;     q <- (1 - exp(-delta_t * (n_events/t_at_risk))) * (n_events - n_events_exp_e2)/n_events;     q[n_events == 0] <- 0;     cumsum(c(1, exp(-cumsum(delta_t * (n_events/t_at_risk)))[-length(n_events/t_at_risk)]) * q); }} \tab \verb{0 + NA_real_} \cr
}

\itemize{
\item Armed with a list of expressions based on \code{estimates}, called
\code{expressions}, for each \code{i}:
\itemize{
\item Evaluate each element of \code{expressions[[i]]} and add the result into
\code{dt}. E.g. \code{s_pch_est} and
\code{s_pch_se}.
\item If \code{conf_methods[[i]]} is not \code{"none"}, compute confidence intervals
by calling \verb{[directadjusting::delta_method_confidence_intervals]}
and add them into \code{dt}.
}
\item If \code{weights} was a \code{data.table}, we perform an additional direct
adjusting step by calling
\verb{[directadjusting::directly_adjusted_estimates]}.
\item If \code{weights} was a \code{data.table}, the summary statistics such as
\code{n_events} are summed over the adjusting strata and will be included
in the output. These are not weighted averages/sums but simple sums.
\item Return \code{dt} invisibly.
}


\strong{popEpi::surv_individual_weights}

Produce a vector of weights, one weight for each row in \code{dt}.
These weights have been called individual weights, Brenner weights,
(Brenner et al 2004, https://doi.org/10.1016/j.ejca.2004.07.007),
pre-weights, and maybe even others. A beloved child has many names.

The idea of these weights is to weigh the individual contribution of each
person to the summary statistics from which the survival function estimates
themselves are produced. They pronounce the influence of under-represented
data and reduce the influence of over-represented data just as the more
conventional computation of weighted averages survival function estimates
does. However, in this individual weighting approach even a single event
can be included in the summary statistics as e.g. 0.80 or 1.20 events
for over and under-represented data respectively.

This function makes producing these weights easier. It performs the
following steps:
\itemize{
\item If \code{is.null(observed_weight_dt)}, \code{observed_weight_dt} is computed
by \code{surv_individual_weights} by simply counting the number of cases
in each stratum in \code{standard_weight_dt}.
\item Merge \code{standard_weight_dt} and \code{observed_weight_dt} into one table.
Scale the standard weights and the observed weights to sum into one
(they are in separate columns). E.g. one stratum has
\code{weight_standard = 0.5} and \code{weight_observed = 0.4}.
\item Compute the individual weights as the standard weights divided by the
observed weights. E.g. one stratum has
\code{weight_brenner = 0.5 / 0.4 = 1.2}.
\item Using left-join, produce a vector of length \code{nrow(dt)} where each row in
\code{dt} gets an individual weight based on its stratum.
A vector of weights is returned.
}


\strong{popEpi::surv_lexis}

Compute survival estimates on a \code{Lexis} dataset (\verb{[Epi::Lexis]}).

Performs the following steps:
\itemize{
\item Call \code{surv_split_merge_aggregate_by_stratum}. If \code{aggre_expr} is \code{NULL},
it is replaced with an internally specified expressions based on
argument \code{estimators}. The resulting table of aggregated data is
stratified by both \code{aggre_by} and by any stratifying columns found in
\code{weights} if a \code{data.table} was supplied as that argument. E.g.
with \code{aggre_by = "sex"} and
\code{weights = data.table::data.table(ag = 1:3, weight = c(100, 150, 200))},
the statistics table is stratified by both \code{sex} and \code{ag}.
With \code{aggre_by = "sex"} and \code{weights = "individual_weight"} the table is
stratified by sex and contains individually weighted statistics.
\item Call \code{surv_estimate} to produce estimates by the strata specified above.
If \code{weights} was \code{NULL} or \code{character} we are done.
}


\strong{popEpi::surv_merge}

\code{popEpi::surv_merge} can be used to merge additional information into
\code{Lexis} data, allowing the use of the \code{Lexis} time scales in the
merge. The typical use-case is to split \code{Lexis} data and then merge
population (expected) hazards to the subject-intervals.
\code{popEpi::surv_merge} performs the following steps:
\itemize{
\item If \code{is.null(merge_dt_harmonisers)}, \code{popEpi::surv_merge} attempts to
automatically determine the harmonisers making use of \code{cut} by looking
at the unique
values of the time scale to merge by in \code{merge_dt} (e.g. calendar year
in \code{ts_cal}):
\itemize{
\item If \code{merge_dt[[col_nm]]} contains numbers we define \code{cut} breaks as the
unique values of
\code{merge_dt[[col_nm]]} and as the ceiling
\code{max(merge_dt[[col_nm]]) + last_diff}. Here \code{last_diff} is the
difference between the highest and second highest values. E.g.
\code{c(1950, 1960, 1970:2020, 2021)} for \code{merge_dt[[col_nm]]}
containing unique values \code{c(1950, 1960, 1970:2020)}.
\item If \code{merge_dt[[col_nm]]} does not contain numbers, an error is
raised because we don't know how to automatically form a
harmoniser.
}
\item Run \code{optional_steps[["pre_default_harmoniser_creation"]](call_env = call_env, eval_env = eval_env, lapply_env = environment())}
if that \code{optional_steps} element exists.
\itemize{
\item With the \code{cut} breaks defined, the automatically created harmoniser
becomes a \code{cut} call with arguments
\itemize{
\item \code{x = col + lex.dur * lex_dur_multiplier}, where \code{COL} is the current
column and \code{lex_dur_multiplier} is by default \code{0.5},
\item \code{breaks} as specified above,
\item \code{right = FALSE}, and
\item \code{labels = FALSE}.
}
\item This results in indices to the breaks, and the harmoniser returns
break values at those indices. E.g. the cut results in
\code{3} in \code{breaks = c(1950, 1960, 1970:2020, 2021)} and output is
\code{1970} for every value of \code{COL + lex.dur / 2} in the interval
\verb{]1970, 1971]}.
}
\item Armed with either user-defined or automatically created
\code{merge_dt_harmonisers}, they are each evaluated to create a temporary
\code{data.table} with harmonised data from \code{dt}. This is performed via
\code{eval} with \code{envir = dt} and \code{enclos = call_env} where \code{call_env} is the
environment where \code{popEpi::surv_merge} was called. Of course if a column
has no harmoniser at this point then it is used as-is. For instance there
is no need to harmonise stratifying columns because they are not changed
by splitting the \code{Lexis} data.
\item Then we perform the actual merge between \code{merge_dt} and the harmonised
data. This merges in data from \code{merge_dt} into every row of \code{dt} in-place.
So \code{dt} is modified and no additional copy is taken for the sake of
efficiency.
\item Each merged-in column from \code{merge_dt} (all columns not in \code{merge_dt_by})
are inspected for missing values. If there are any, an error is raised.
This usually occurs if \code{merge_dt} does not contain data for all data in
\code{dt}. For instance it only covers years 1950-2020 but \code{dt} contains also
data for 2021. This error helps you to spot those problems early instead
of producing nonsense results downstream.
\item Returns \code{dt} invisibly after adding columns from
\code{merge_dt} into \code{dt} in-place, without taking a copy.
}


\strong{popEpi::surv_split_merge_aggregate_by_stratum}

\code{popEpi::surv_split_merge_aggregate_by_stratum} can be used to split \code{Lexis}
(\verb{[Epi::Lexis]}) data, merge something to it after the merge, and
then perform an aggregation step. The following steps are performed:
\itemize{
\item Call
\code{optional_steps[["on_entry"]](eval_env = eval_env, call_env = call_env)}
if that \code{optional_steps} element exists.
\code{eval_env} is the temporary evaluation environment of
\code{popEpi::surv_split_merge_aggregate_by_stratum} which contains all
contains all the arguments of
\code{popEpi::surv_split_merge_aggregate_by_stratum} and \code{call_env} is the environment
where it was called.
\item Call
\code{on.exit(optional_steps[["on_exit"]](eval_env = eval_env, call_env = call_env))}
if that \code{optional_steps} element exists.
\item For each stratum in \code{aggre_by}:
\itemize{
\item Run
\code{optional_steps[["stratum_on_entry"]](stratum_eval_env = stratum_eval_env, eval_env = eval_env, call_env = call_env)}
if that \code{optional_steps} element exists.
\code{stratum_eval_env} is the environment where the stratum-specific
steps are performed.
\item Run
\code{popEpi::splitMulti} on the subset of \code{dt} which contains data from
the current stratum.
\item Run
\code{optional_steps[["stratum_post_split"]](stratum_eval_env = stratum_eval_env, eval_env = eval_env, call_env = call_env)}
if that \code{optional_steps} element exists.
\item Run
\code{surv_merge} with \code{merge_dt}, \code{merge_dt_by}, and
\code{merge_dt_harmonisers}, if \code{merge_dt} has been supplied.
\item Run
\code{optional_steps[["stratum_post_merge"]](stratum_eval_env = stratum_eval_env, eval_env = eval_env, call_env = call_env)}
if that \code{optional_steps} element exists.
\item Evaluate \code{aggre_expr} in the context of the split data
with merged-in additional data. The enclosing environment is
\code{call_env}. See \code{?eval}. This results in a \code{data.table} that
contains one row per interval of \code{aggre_ts_col_nms}.
\item Run
\code{optional_steps[["stratum_post_aggregation"]](stratum_eval_env = stratum_eval_env, eval_env = eval_env, call_env = call_env)}
if that \code{optional_steps} element exists.
}
\item After every stratum has been processed, set proper \code{data.table}
attributes on the resulting big table and call \code{data.table::setkeyv}
with \code{cols = c(names(aggre_by), "box_id")}. We store the metadata
\code{list(stratum_col_nms, value_col_nms)} into the attribute named
\code{surv_split_merge_aggregate_by_stratum_meta}, where
\code{stratum_col_nms = names(aggre_by)}, \code{ts_col_nms = aggre_ts_col_nms}, and
\code{value_col_nms} are the names of the columns resulting from \code{aggre_expr}.
\item Run
\code{optional_steps[["post_aggregation"]](eval_env = eval_env, call_env = call_env)}
if that \code{optional_steps} element exists.
\item Return a \code{data.table} with stratum columns as specified via
\code{aggre_by} and value columns as specified via \code{aggre_expr}.
}
}

\section{News for version 0.5.0}{


New function \code{surv_estimate} for estimating arbitrary survival time
functions using aggregated data.
}

\examples{

# popEpi::surv_estimate
dt <- data.table::data.table(
  ts_fut_start = seq(0, 5 - 1 / 12, 1 / 12),
  ts_fut_stop = seq(1 / 12, 5, 1 / 12),
  n_events = rpois(n = 60, lambda = 60:1),
  t_at_risk = rpois(n = 60, lambda = 300:240)
)
data.table::set(
  x = dt,
  j = "my_h_pch",
  value = dt[["n_events"]] / dt[["t_at_risk"]]
)
sdt <- popEpi::surv_estimate(
  dt = dt,
  ts_fut_col_nm = "ts_fut",
  value_col_nms = c("n_events", "t_at_risk"),
  estimators = c("h_pch", "s_pch"),
  conf_methods = "log-log"
)
stopifnot(
  c("h_pch_est", "s_pch_est") \%in\% names(sdt),
  dt[["my_h_pch"]] == sdt[["h_pch_est"]]
)
sdt <- popEpi::surv_estimate(
  dt = dt,
  ts_fut_col_nm = "ts_fut",
  value_col_nms = c("n_events", "t_at_risk"),
  estimators = list(
    "h_pch",
    my_surv = list(
      est = quote(
        exp(-cumsum((ts_fut_stop - ts_fut_start) * h_pch_est))
      ),
      se = quote(rep(0.0, length(ts_fut_start)))
    )
  ),
  conf_methods = c("log", "none")
)
stopifnot(
  c("h_pch_est", "my_surv_est") \%in\% names(sdt)
)
sdt <- popEpi::surv_estimate(
  dt = dt,
  ts_fut_col_nm = "ts_fut",
  value_col_nms = c("n_events", "t_at_risk"),
  estimators = list(
    "h_pch",
    "s_pch"
  ),
  conf_methods = list(
    "log",
    list(
      g = quote(stats::qnorm(p = theta)),
      g_inv = quote(stats::pnorm(q = g))
    )
  )
)
stopifnot(
  c("h_pch_est", "s_pch_est") \%in\% names(sdt)
)

# popEpi::surv_merge
lexis <- Epi::Lexis(
  entry = list(ts_fut = 0.0, ts_cal = 2010.3, ts_age = 56.8),
  exit = list(ts_cal = 2024.9999),
  entry.status = 0L,
  exit.status = 0L
)
lexis$sex <- 0L
lexis <- popEpi::splitMulti(
  data = lexis,
  breaks = list(ts_fut = seq(0, 3, 1 / 12))
)
my_merge_dt <- data.table::CJ(sex = 0:1, ts_age = 0:100, ts_cal = 2000:2025)
data.table::set(
  x = my_merge_dt,
  j = "merge_value",
  value = runif(nrow(my_merge_dt))
)
popEpi::surv_merge(
  dt = lexis,
  merge_dt = my_merge_dt,
  merge_dt_by = c("sex", "ts_age", "ts_cal")
)
stopifnot(
  "merge_value" \%in\% names(lexis),
  !is.na(lexis[["merge_value"]])
)
data.table::set(
  x = lexis,
  j = "merge_value",
  value = NULL
)
popEpi::surv_merge(
  dt = lexis,
  merge_dt = my_merge_dt,
  merge_dt_by = c("sex", "ts_age", "ts_cal"),
  merge_dt_harmonisers = list(
    ts_cal = quote(as.integer(ts_cal)),
    ts_age = quote(as.integer(ts_age))
  )
)
stopifnot(
  "merge_value" \%in\% names(lexis),
  !is.na(lexis[["merge_value"]])
)

}
