% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/wip_lexis_merge.R
\name{lexis_merge}
\alias{lexis_merge}
\title{Merge Data into \code{Lexis} Object}
\usage{
lexis_merge(
  dt,
  merge_dt,
  merge_dt_by,
  merge_dt_harmonisers = NULL,
  optional_steps = NULL
)
}
\arguments{
\item{dt}{\verb{[Lexis]} (no default)

A \code{Lexis} dataset (\verb{[Epi::Lexis]} / \verb{[Lexis_dt]}).}

\item{merge_dt}{\verb{[data.table, NULL]} (no default or default \code{NULL})

A \code{data.table} to merge with \code{dt}, possibly after splitting.
\itemize{
\item \code{NULL}: Allowed only if this is the function's default for this argument.
When both \code{merge_dt} and \code{merge_dt_by} are \code{NULL}, no merge is performed.
\item \code{data.table}: Merge this table. Typically this contains the
expected hazards for the estimation of relative or net survival.
}}

\item{merge_dt_by}{\verb{[character, NULL]} (no default or default \code{NULL})

Names of columns in both \code{merge_dt} and \code{dt} by which \code{merge_dt} will be
merged with \code{ dt}.
\itemize{
\item \code{NULL}: Allowed only if this is the function's default for this argument.
When both \code{merge_dt} and \code{merge_dt_by} are \code{NULL}, no merge is performed.
\item \code{character}: Use these columns.
}}

\item{merge_dt_harmonisers}{\verb{[NULL, list]} (default \code{NULL})

Optional list of quoted expressions which, when evaluated, harmonise
data in \code{dt} (possibly after splitting) to look the same as the data in
\code{merge_dt}. For example, if \code{merge_dt} contains expected hazards by
calendar year \code{ts_cal} and 1-year age group \code{ts_age}, and if \code{dt} has been
split into monthly survival intervals, then we must somehow find the
correct row in \code{merge_dt} for each row in \code{dt}. E.g. \code{ts_cal = 2010.5323}
and \code{ts_age = 76.4435} need to be harmonised into values found in
\code{merge_dt} such as \code{ts_cal = 2010} and \code{ts_age = 76}.
\itemize{
\item \code{NULL}: This function comes up with reasonable harmonisers if possible.
See \strong{Details}.
\item \code{list}: Each element must a quoted expression (\verb{[quote]}) and each
element must have a name corresponding to a column name in both \code{dt}
and \code{merge_dt}. See \strong{Examples}.
}}

\item{optional_steps}{\verb{[NULL, list]} (default \code{NULL})

Optional steps to perform during the function's run.
\itemize{
\item \code{NULL}: No additional steps are performed.
\item \code{list}: Each element is named and a function. See \strong{Details}
For what each functions you can make use of what their arguments should
be.
}}
}
\description{
Function(s) to merge data into \code{Lexis} objects intelligently when merging
is (partially) based on time scales.
}
\examples{
# popEpi::lexis_merge
lexis <- Epi::Lexis(
  entry = list(ts_fut = 0.0, ts_cal = 2010.3, ts_age = 56.8),
  exit = list(ts_cal = 2024.9999),
  entry.status = 0L,
  exit.status = 0L
)
lexis$sex <- 0L
lexis <- popEpi::splitMulti(
  data = lexis,
  breaks = list(ts_fut = seq(0, 3, 1 / 12))
)
my_merge_dt <- data.table::CJ(sex = 0:1, ts_age = 0:100, ts_cal = 2000:2025)
data.table::set(
  x = my_merge_dt,
  j = "merge_value",
  value = runif(nrow(my_merge_dt))
)
popEpi::lexis_merge(
  dt = lexis,
  merge_dt = my_merge_dt,
  merge_dt_by = c("sex", "ts_age", "ts_cal")
)
stopifnot(
  "merge_value" \%in\% names(lexis),
  !is.na(lexis[["merge_value"]])
)
data.table::set(
  x = lexis,
  j = "merge_value",
  value = NULL
)
popEpi::lexis_merge(
  dt = lexis,
  merge_dt = my_merge_dt,
  merge_dt_by = c("sex", "ts_age", "ts_cal"),
  merge_dt_harmonisers = list(
    ts_cal = quote(as.integer(ts_cal)),
    ts_age = quote(as.integer(ts_age))
  )
)
stopifnot(
  "merge_value" \%in\% names(lexis),
  !is.na(lexis[["merge_value"]])
)

}
\seealso{
Other Lexis_functions: 
\code{\link{lexis_funs}},
\code{\link{lexis_split_merge_aggregate_by_stratum}()}
}
\concept{Lexis_functions}
