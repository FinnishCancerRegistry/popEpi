% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/wip_lexis_merge.R
\name{lexis_merge}
\alias{lexis_merge}
\title{Merge Data into \code{Lexis} Object}
\usage{
lexis_merge(
  dt,
  merge_dt,
  merge_dt_by,
  merge_dt_harmonisers = NULL,
  optional_steps = NULL
)
}
\arguments{
\item{dt}{\verb{[Lexis]} (no default)

A \code{Lexis} dataset (\verb{[Epi::Lexis]} / \verb{[Lexis_dt]}).}

\item{merge_dt}{\verb{[data.table, NULL]} (no default or default \code{NULL})

A \code{data.table} to merge with \code{dt}, possibly after splitting.
\itemize{
\item \code{NULL}: Allowed only if this is the function's default for this argument.
When both \code{merge_dt} and \code{merge_dt_by} are \code{NULL}, no merge is performed.
\item \code{data.table}: Merge this table. Typically this contains the
expected hazards for the estimation of relative or net survival.
}}

\item{merge_dt_by}{\verb{[character, NULL]} (no default or default \code{NULL})

Names of columns in both \code{merge_dt} and \code{dt} by which \code{merge_dt} will be
merged with \code{ dt}.
\itemize{
\item \code{NULL}: Allowed only if this is the function's default for this argument.
When both \code{merge_dt} and \code{merge_dt_by} are \code{NULL}, no merge is performed.
\item \code{character}: Use these columns.
}}

\item{merge_dt_harmonisers}{\verb{[NULL, list]} (default \code{NULL})

Optional list of quoted expressions which, when evaluated, harmonise
data in \code{dt} (possibly after splitting) to look the same as the data in
\code{merge_dt}. For example, if \code{merge_dt} contains expected hazards by
calendar year \code{ts_cal} and 1-year age group \code{ts_age}, and if \code{dt} has been
split into monthly survival intervals, then we must somehow find the
correct row in \code{merge_dt} for each row in \code{dt}. E.g. \code{ts_cal = 2010.5323}
and \code{ts_age = 76.4435} need to be harmonised into values found in
\code{merge_dt} such as \code{ts_cal = 2010} and \code{ts_age = 76}.
\itemize{
\item \code{NULL}: This function comes up with reasonable harmonisers if possible.
See \strong{Details}.
\item \code{list}: Each element must a quoted expression (\verb{[quote]}) and each
element must have a name corresponding to a column name in both \code{dt}
and \code{merge_dt}. See \strong{Examples}.
}}

\item{optional_steps}{\verb{[NULL, list]} (default \code{NULL})

Optional steps to perform during the function's run.
\itemize{
\item \code{NULL}: No additional steps are performed.
\item \code{list}: Each element is named and a function. See \strong{Details}
For what each functions you can make use of what their arguments should
be.
}}
}
\value{
\strong{popEpi::lexis_merge}

Returns \code{dt} invisibly after adding columns from
\code{merge_dt} into \code{dt} in-place, without taking a copy.
}
\description{
Function(s) to merge data into \code{Lexis} objects intelligently when merging
is (partially) based on time scales.
}
\section{Functions}{

\strong{popEpi::lexis_merge}

\code{popEpi::lexis_merge} can be used to merge additional information into
\code{Lexis} data, allowing the use of the \code{Lexis} time scales in the
merge. The typical use-case is to split \code{Lexis} data and then merge
population (expected) hazards to the subject-intervals.
\code{popEpi::lexis_merge} performs the following steps:
\itemize{
\item Run
\code{optional_steps[["on_entry"]](call_env = call_env, eval_env = eval_env)}
if that \code{optional_steps} element exists. \code{call_env} is the environment
where this function was called and \code{eval_env} is the temporary environment
in which the commands that this function consists of are evaluated.
\item Run
\code{on.exit(optional_steps[["on_exit"]](call_env = call_env, eval_env = eval_env))}
if that \code{optional_steps} element exists.
\item If \code{is.null(merge_dt_harmonisers)}, attempt to
automatically determine the harmonisers making use of \code{cut} by looking
at the unique
values of the time scale to merge by in \code{merge_dt} (e.g. calendar year
in \code{ts_cal}):
\itemize{
\item If \code{merge_dt[[col_nm]]} contains numbers we define \code{cut} breaks as the
unique values of
\code{merge_dt[[col_nm]]} and as the ceiling
\code{max(merge_dt[[col_nm]]) + last_diff}. Here \code{last_diff} is the
difference between the highest and second highest values. E.g.
\code{c(1950, 1960, 1970:2020, 2021)} for \code{merge_dt[[col_nm]]}
containing unique values \code{c(1950, 1960, 1970:2020)}.
\item If \code{merge_dt[[col_nm]]} does not contain numbers, an error is
raised because we don't know how to automatically form a
harmoniser.
}
\item Run
\code{optional_steps[["pre_default_harmoniser_creation"]](call_env = call_env, eval_env = eval_env, lapply_eval_env = lapply_eval_env)}
if that \code{optional_steps} element exists.
Here \code{lapply_eval_env} is similar to \code{eval_env} but it is the
evaluation environment of the anonymous function passed to \code{lapply}
which attempts to handle each harmoniser.
\itemize{
\item With the \code{cut} breaks defined, the automatically created harmoniser
becomes a \code{cut} call with arguments
\itemize{
\item \code{x = col + lex.dur * lex_dur_multiplier}, where \code{COL} is the current
column and \code{lex_dur_multiplier} is by default \code{0.5},
\item \code{breaks} as specified above,
\item \code{right = FALSE}, and
\item \code{labels = FALSE}.
}
\item This results in indices to the breaks, and the harmoniser returns
break values at those indices. E.g. the cut results in
\code{3} in \code{breaks = c(1950, 1960, 1970:2020, 2021)} and output is
\code{1970} for every value of \code{COL + lex.dur / 2} in the interval
\verb{]1970, 1971]}.
}
\item Run
\code{optional_steps[["post_merge_dt_harmonisers"]](call_env = call_env, eval_env = eval_env)}
if that \code{optional_steps} element exists.
\item Armed with either user-defined or automatically created
\code{merge_dt_harmonisers}, they are each evaluated to create a temporary
\code{data.table} with harmonised data from \code{dt}. This is performed via
\code{eval} with \code{envir = dt} and \code{enclos = call_env} where \code{call_env} is the
environment where \code{popEpi::lexis_merge} was called. Of course if a column
has no harmoniser at this point then it is used as-is. For instance there
is no need to harmonise stratifying columns because they are not changed
by splitting the \code{Lexis} data.
\item Run
\code{optional_steps[["post_harmonisation"]](call_env = call_env, eval_env = eval_env)}
if that \code{optional_steps} element exists.
\item Then we perform the actual merge between \code{merge_dt} and the harmonised
data. This merges in data from \code{merge_dt} into every row of \code{dt} in-place.
So \code{dt} is modified and no additional copy is taken for the sake of
efficiency.
\item Run
\code{optional_steps[["post_merge"]](call_env = call_env, eval_env = eval_env)}
if that \code{optional_steps} element exists.
\item Each merged-in column from \code{merge_dt} (all columns not in \code{merge_dt_by})
are inspected for missing values. If there are any, an error is raised.
This usually occurs if \code{merge_dt} does not contain data for all data in
\code{dt}. For instance it only covers years 1950-2020 but \code{dt} contains also
data for 2021. This error helps you to spot those problems early instead
of producing nonsense results downstream.
\item Returns \code{dt} invisibly after adding columns from
\code{merge_dt} into \code{dt} in-place, without taking a copy.
}
}

\examples{
# popEpi::lexis_merge
lexis <- Epi::Lexis(
  entry = list(ts_fut = 0.0, ts_cal = 2010.3, ts_age = 56.8),
  exit = list(ts_cal = 2024.9999),
  entry.status = 0L,
  exit.status = 0L
)
lexis$sex <- 0L
lexis <- popEpi::splitMulti(
  data = lexis,
  breaks = list(ts_fut = seq(0, 3, 1 / 12))
)
my_merge_dt <- data.table::CJ(sex = 0:1, ts_age = 0:100, ts_cal = 2000:2025)
data.table::set(
  x = my_merge_dt,
  j = "merge_value",
  value = runif(nrow(my_merge_dt))
)
popEpi::lexis_merge(
  dt = lexis,
  merge_dt = my_merge_dt,
  merge_dt_by = c("sex", "ts_age", "ts_cal")
)
stopifnot(
  "merge_value" \%in\% names(lexis),
  !is.na(lexis[["merge_value"]])
)
data.table::set(
  x = lexis,
  j = "merge_value",
  value = NULL
)
popEpi::lexis_merge(
  dt = lexis,
  merge_dt = my_merge_dt,
  merge_dt_by = c("sex", "ts_age", "ts_cal"),
  merge_dt_harmonisers = list(
    ts_cal = quote(as.integer(ts_cal)),
    ts_age = quote(as.integer(ts_age))
  )
)
stopifnot(
  "merge_value" \%in\% names(lexis),
  !is.na(lexis[["merge_value"]])
)

}
\seealso{
Other Lexis_functions: 
\code{\link{lexis_funs}},
\code{\link{lexis_split_merge_aggregate_by_stratum}()}
}
\concept{Lexis_functions}
